-- MANUAL/master jackz_chat.lua
-- AUTOGENERATED CODE ON Friday 28th, April 2023 AT 03:48:09 PM
local SCRIPT_SOURCE = "MANUAL"
local SCRIPT_BRANCH = "master"
local BRANCH_LAST_COMMIT = "e0fd8a1312201ea3b4966c6e34e17ff8e0c0b7c7"
local SCRIPT_BRANCH_IDS = {"actions-fix","jackzscript","master","release"}
local SCRIPT_BRANCH_NAMES = {{"actions-fix"},{"jackzscript"},{"dev"},{"release"}}
-- END AUTOGENERATED CODE --

-- MANUAL/master jackz_chat.lua
-- AUTOGENERATED CODE ON Friday 28th, April 2023 AT 03:47:02 PM
local SCRIPT_SOURCE = "MANUAL"
local SCRIPT_BRANCH = "master"
local BRANCH_LAST_COMMIT = "c41853db7e088c7eb2e8a1dc91163a19661c97bf"
local SCRIPT_BRANCH_IDS = {"actions-fix","jackzscript","master","release"}
local SCRIPT_BRANCH_NAMES = {{"actions-fix"},{"jackzscript"},{"dev"},{"release"}}
-- END AUTOGENERATED CODE --

-- Stand Chat
-- Created By Jackz
local SCRIPT = "jackz_chat"
VERSION = "1.3.0"
local LANG_TARGET_VERSION = "1.4.3" -- Target version of translations.lua lib


-- TEMPLATE: master/log.lua --
Log = {}
if SCRIPT_DEBUG == nil then
    SCRIPT_DEBUG = false
end
function Log._log(prefix, ...)
    local mod = debug.getinfo(3, "n").name or debug.getinfo(4, "n").name or "_anon_func"
    local msg = ""
    for _, a in ipairs(...) do
        if a == nil then a = "<nil>" end
        if type(a) == "table" then a = dumpTable(a) end
        msg = msg .. tostring(a) .. "\t"
    end
    if prefix then prefix = "[" .. prefix .. "] "
    else prefix = "" end
    util.log(string.format("%s%s:%s/%s: %s", prefix, SCRIPT_NAME, SCRIPT_SOURCE or "DEV", mod, msg))
end
function Log.debug(...)
    if SCRIPT_DEBUG then
        local arg = {...}
        Log._log("debug", arg)
    end
end
function Log.debugTable(table)
    if SCRIPT_DEBUG then
        local mod = debug.getinfo(3, "n").name or debug.getinfo(4, "n").name or "_anon_func"
        util.log(string.format("%s:%s/%s: %s", SCRIPT_NAME, SCRIPT_SOURCE or "DEV", mod, dumpTable(table)))
    end
end
function Log.warn(...)
    local arg = {...}
    Log._log("Warn", arg)
end
function Log.error(...)
    local arg = {...}
    Log._log("Error", arg)
end
function Log.severe(...)
    local arg = {...}
    Log._log("Severe", arg)
    util.stop_script()
end
function Log.log(...)
    local arg = {...}
    Log._log(nil, arg)
end

function dumpTable(o)
    if type(o) == 'table' then
       local s = '{ '
       for k,v in pairs(o) do
          if type(k) ~= 'number' then k = '"'..k..'"' end
          s = s .. '['..k..'] = ' .. dumpTable(v) .. ','
       end
       return s .. '} '
    elseif type(o) == "string" then
        return '"' .. o .. "'"
    else
       return tostring(o)
    end
end
-- END TEMPLATE --
-- TEMPLATE: master/manual.lua --
-- Check for updates & auto-update:
function check_for_update(branch)
    async_http.init("jackz.me", "/stand/updatecheck.php?ucv=2&script=" .. SCRIPT .. "&v=" .. VERSION  .. "&branch=" .. (branch or "master") .. "&commit=" .. (BRANCH_LAST_COMMIT or ""), function(body, res_headaers, status_code)
        if status_code == 200 then
            local chunks = {}
            for substring in string.gmatch(body, "%S+") do
                table.insert(chunks, substring)
            end
            if chunks[1] == "OUTDATED" then
                util.toast(SCRIPT_NAME .. ": An update is available (V" .. chunks[2] .. ")")
                SCRIPT_META_UPDATE_ACTION.menu_name = "Update (V" .. chunks[2] .. ")"
                SCRIPT_META_UPDATE_ACTION.help_text = "Update from v" .. VERSION .. " to v" .. chunks[2]
                SCRIPT_META_UPDATE_ACTION.visible = true
            end
        else
            util.toast(SCRIPT .. ": Could not auto update due to server error (HTTP " .. status_code .. ")\nPlease download latest update manually.\nhttps://jackz.me/stand/get-latest-zip", 2)
        end
    end)
    async_http.dispatch()
end
function check_for_old_version()
    local file = io.open(SCRIPT_OLD_VERSION_PATH, "r")
    if file then
        local chunks = {}
        for substring in io.lines("SCRIPT_OLD_VERSION_PATH") do
            table.insert(chunks, substring)
        end
        SCRIPT_META_REVERT_ACTION.set_menu_name("Revert to v" .. chunks[1])
        SCRIPT_META_REVERT_ACTION.help_text = "Revert to old v" .. chunks[1] .. "\nBranch: " .. chunks[2] .. "\nCommit: " .. chunks[3]

        file:close()
        SCRIPT_META_REVERT_ACTION.visible = false
    end
end
function download_script_update(branch, on_success, on_err)
    os.rename(filesystem.scripts_dir()  .. SCRIPT_RELPATH, SCRIPT_OLD_VERSION_PATH)
    local vFile = io.open(SCRIPT_OLD_VERSION_PATH .. ".meta", "w")
    if not vFile then
        Log.error("script update failed: couldnt open file")
        if on_err then on_err(0, "couldnt open file") end
        return
    end
    vFile:write("V" .. VERSION .. "\n" .. SCRIPT_BRANCH .. "\n" .. BRANCH_LAST_COMMIT)
    vFile:close()

    async_http.init("jackz.me", "/stand/get-lua.php?script=" .. SCRIPT .. "&source=manual&branch=" .. (branch or "master"), function(body, res_headers, status_code)
        if status_code == 200 then
            local file = io.open(filesystem.scripts_dir()  .. SCRIPT_RELPATH, "w")
            if file then
                file:write(body:gsub("\r", "") .. "\n") -- have to strip out \r for some reason, or it makes two lines. ty windows
                file:close()
                Log.log("Updated ", SCRIPT_NAME, "to branch", branch or "master")
                if on_success then on_success() end
            else
                Log.error("script update failed: couldnt open file")
                if on_err then on_err(0, "couldnt open file") end
            end
        else
            Log.error("script update failed due to server error: " .. status_code .. "\n" .. body)
            if on_err then on_err(status_code, body) end
        end
    end, on_err)
    async_http.dispatch()
end
check_for_update(SCRIPT_BRANCH)

function download_lib_update(lib, on_success, on_error)
    local lockPath = filesystem.scripts_dir() .. "/lib/" .. lib .. ".lock"
    if filesystem.exists(lockPath) then
        if on_error then on_error() end
        util.log(SCRIPT_NAME .. ": Skipping lib update \" .. lib .. \", found update lockfile")
    end
    local lock = io.open(lockPath, "w")
    if lock == nil then
        util.toast(SCRIPT_NAME .. ": Could not create lockfile, skipping update", TOAST_ALL)
        if on_error then on_error() end
        return
    end
    lock:close()
    async_http.init("jackz.me", "/stand/get-lua.php?script=lib/" .. lib .. "&source=" .. SCRIPT_SOURCE .. "&branch=" .. (SCRIPT_BRANCH or "master"), function(result, res_headers, status_code)
        os.remove(lockPath)
        if status_code ~= 200 or result:startswith("<") or result == "" then
            util.toast("Lib returned invalid response for \"" .. lib .. "\"\nSee logs for details")
            util.log(string.format("%s: Lib \"%s\" returned: %s", SCRIPT_NAME, lib, result))
            if on_error then on_error() end
            return
        end
        local file = io.open(filesystem.scripts_dir() .. "/lib/" .. lib, "w")
        if file == nil then
            util.toast("Could not write lib file for: " .. lib .. "\nSee logs for details")
            util.log(string.format("%s: Resource \"%s\" file could not be created.", SCRIPT_NAME, lib))
            if on_error then on_error() end
            return
        end
        file:write(result:gsub("\r", "") .. "\n")
        file:close()
        Log.log("Updated lib ", lib, "for", SCRIPT_NAME, "to branch", SCRIPT_BRANCH or "master")
        util.toast(SCRIPT .. ": Automatically updated lib '" .. lib .. "'")
        if on_success then on_success() end
    end, function(e)
        util.toast(SCRIPT .. " cannot load: Library files are missing. (" .. lib .. ")", 10)
        os.remove(lockPath)
        if on_error then on_error() end
        util.stop_script()
    end)
    async_http.dispatch()
    return lockPath
end
function download_resources_update(filepath, destOverwritePath)
    local lockPath = filesystem.scripts_dir() .. "/lib/" .. filepath .. ".lock"
    if filesystem.exists(lockPath) then
        util.log(SCRIPT_NAME .. ": Skipping resource update \" .. lib .. \", found update lockfile")
    end
    local lock = io.open(lockPath, "w")
    if lock == nil then
        util.toast(SCRIPT_NAME .. ": Could not create lockfile, skipping update", TOAST_ALL)
        return
    end
    lock:close()
    async_http.init("jackz.me", "/stand/get-lua.php?script=resources/" .. filepath .. "&source=" .. SCRIPT_SOURCE .. "&branch=" .. (SCRIPT_BRANCH or "master"), function(result, res_headers, status_code)
        os.remove(lockPath)
        if status_code ~= 200 or result:startswith("<") then
            util.toast("Resource returned invalid response for \"" .. filepath .. "\"\nSee logs for details")
            util.log(string.format("%s: Resource \"%s\" returned: %s", SCRIPT_NAME, filepath, result))
            return
        end
        local file = io.open(filesystem.resources_dir() .. (destOverwritePath or filepath), "w")
        if file == nil then
            util.toast("Could not write resource file for: " .. filepath .. "\nSee logs for details")
            util.log(string.format("%s: Resource \"%s\" file could not be created.", SCRIPT_NAME, filepath))
            return
        end
        file:write(result:gsub("\r", "") .. "\n")
        file:close()
        Log.log("Updated resource ", filepath, "for", SCRIPT_NAME, "to branch", SCRIPT_BRANCH or "master")
        util.toast(SCRIPT .. ": Automatically updated resource '" .. filepath .. "'")
    end, function(e)
        os.remove(lockPath)
        util.toast(SCRIPT .. " cannot load: Library files are missing. (" .. filepath .. ")", 10)
        util.stop_script()
    end)
    async_http.dispatch()
end

-- END TEMPLATE --
-- TEMPLATE: master/common.lua --
-- People keep trying to run stuff on non-stand
if not filesystem.stand_dir then
    print("Unsupported. Only stand is supported")
    return
end
----------------------------------------------------------------
-- Version Check
function get_version_info(version)
    if not version then error("Missing version", 2) end
    local major, minor, patch = version:match("(%d+)%.(%d+)%.(%d+)")
    return {
        major = tonumber(major) or 0,
        minor = tonumber(minor) or 0,
        patch = tonumber(patch) or 0
    }
end
function compare_version(a, b)
    local av = get_version_info(a)
    local bv = get_version_info(b)
    if not av or not bv then error("Missing versions to compare") end
    if av.major > bv.major then return 1
    elseif av.major < bv.major then return -1
    elseif av.minor > bv.minor then return 1
    elseif av.minor < bv.minor then return -1
    elseif av.patch > bv.patch then return 1
    elseif av.patch < bv.patch then return -1
    else return 0 end
end
if SCRIPT_BRANCH and SCRIPT_BRANCH == "release" then
    local VERSION_FILE_PATH = filesystem.store_dir() .. "jackz_versions.txt"
    if not filesystem.exists(VERSION_FILE_PATH) then
        local versionFile = io.open(VERSION_FILE_PATH, "w")
        if versionFile then
            versionFile:close()
        end
    end
    local versionFile = io.open(VERSION_FILE_PATH, "r+")
    if versionFile then
        local versions = {}
        for line in versionFile:lines("l") do
            local script, version = line:match("(%g+): (%g+)")
            if script then
                versions[script] = version
            end
        end
        if versions[SCRIPT_NAME] == nil or compare_version(VERSION, versions[SCRIPT_NAME]) == 1 then
            if versions[SCRIPT_NAME] ~= nil then
                async_http.init("jackz.me", "/stand/changelog.php?raw=1&script=" .. SCRIPT_NAME .. "&since=" .. versions[SCRIPT_NAME] .. "&branch=" .. (SCRIPT_BRANCH or "master"), function(result)
                    util.toast("Changelog for " .. SCRIPT_NAME .. " version " .. VERSION .. ":\n" .. result)
                end, function() util.log(SCRIPT_NAME ..": Could not get changelog") end)
                async_http.dispatch()
            end
            versions[SCRIPT_NAME] = VERSION
            versionFile:seek("set", 0)
            versionFile:write("# DO NOT EDIT ! File is used for changelogs\n")
            for script, version in pairs(versions) do
                versionFile:write(script .. ": " .. version .. "\n")
            end
        end
        versionFile:close()
    else
        util.log(SCRIPT_NAME .. ": Failed to access to version file")
    end
end

-- END Version Check
------------------------------------------------------------------
function show_busyspinner(text)
    HUD.BEGIN_TEXT_COMMAND_BUSYSPINNER_ON("STRING")
    HUD.ADD_TEXT_COMPONENT_SUBSTRING_PLAYER_NAME(text)
    HUD.END_TEXT_COMMAND_BUSYSPINNER_ON(2)
end

----------------------------------------------------------------
---- SCRIPT META - LIST
----------------------------------------------------------------
SCRIPT_META_LIST = menu.list(menu.my_root(), "Script Meta")
menu.divider(SCRIPT_META_LIST, SCRIPT_NAME .. " V" .. VERSION)
menu.hyperlink(SCRIPT_META_LIST, "View full changelog", "https://jackz.me/stand/changelog?html=1&reverse=1&script=" .. SCRIPT_NAME)
menu.hyperlink(SCRIPT_META_LIST, "Jackz's Guilded", "https://www.guilded.gg/i/k8bMDR7E?cid=918b2f61-989c-41c4-ba35-8fd0e289c35d&intent=chat", "Get help, submit suggestions, report bugs, or be with other users of my scripts")
menu.hyperlink(SCRIPT_META_LIST, "Jackz's Discord", "https://discord.gg/NnJrkGppfb", "Get help, submit suggestions, report bugs, or be with other users of my scripts")
menu.hyperlink(SCRIPT_META_LIST, "Github Source", "https://github.com/Jackzmc/lua-scripts", "View all my lua scripts on github")

----------------------------------------------------------------
---- VERSION
----------------------------------------------------------------
SCRIPT_OLD_VERSION_PATH = filesystem.store_dir() .. "/old-" .. SCRIPT_FILENAME
menu.divider(menu.my_root(), "Version")
SCRIPT_META_UPDATE_ACTION = menu.action(menu.my_root(), "Update", {}, "[invalid state]", function()
    SCRIPT_META_UPDATE_ACTION:removeHandler()
    download_script_update(SCRIPT_BRANCH, function()
        util.toast(SCRIPT .. " was updated to V" .. chunks[2] .. "\nScript is restarting to apply changes", TOAST_ALL)
        util.restart_script()
    end, function()
        util.toast(SCRIPT .. ": Failed to update to V" .. chunks[2] .. ".\nPlease download latest update manually.\nhttps://jackz.me/stand/get-latest-zip", 2)
    end)
end)
SCRIPT_META_REVERT_ACTION = menu.action(menu.my_root(), "Revert", {}, "[invalid state]", function()
    SCRIPT_META_REVERT_ACTION:removeHandler()
    if filesystem.exists(SCRIPT_OLD_VERSION_PATH) then
        os.rename(SCRIPT_OLD_VERSION_PATH, filesystem.scripts_dir()  .. SCRIPT_RELPATH)
        util.toast(SCRIPT .. " was reverted to previous version\nScript is restarting to apply changes", TOAST_ALL)
        util.restart_script()
    else
        util.toast("There is no old verison to restore to")
    end
end)
SCRIPT_META_UPDATE_ACTION.visible = false
SCRIPT_META_REVERT_ACTION.visible = false
--#p:END
if SCRIPT_SOURCE == "MANUAL" then
    menu.list_select(SCRIPT_META_LIST, "Release Channel", {SCRIPT_NAME.."channel"}, "Sets the release channel for updates for this script.\nChanging the channel from release may result in bugs.", SCRIPT_BRANCH_NAMES, 1, function(index, name)
        show_busyspinner("Downloading update...")
        download_script_update(SCRIPT_BRANCH_IDS[index], function()
            HUD.BUSYSPINNER_OFF()
            util.log(SCRIPT_NAME .. ": Released channel changed to " .. SCRIPT_BRANCH_IDS[index])
            util.toast("Release channel changed to " .. name .. " (" .. SCRIPT_BRANCH_IDS[index] .. ")\nReload to apply changes")
        end, function()
            util.toast("Failed to download latest version for release channel.")
        end)
    end)
else
    menu.readonly(SCRIPT_META_LIST, "Release Channel", "Use the manual version from https://jackz.me/stand/get-latest-zip to change the release channel.")
end
menu.readonly(SCRIPT_META_LIST, "Build Commit", BRANCH_LAST_COMMIT and BRANCH_LAST_COMMIT:sub(1,10) or "Dev Build")

----------------------------------------------------------------
---- MISC
----------------------------------------------------------------
menu.divider(menu.my_root(), "")
if _lang ~= nil then
    menu.hyperlink(SCRIPT_META_LIST, "Help Translate", "https://jackz.me/stand/translate/?script=" .. SCRIPT, "If you wish to help translate, this script has default translations fed via google translate, but you can edit them here:\nOnce you make changes, top right includes a save button to get a -CHANGES.json file, send that my way.")
    _lang.add_language_selector_to_menu(SCRIPT_META_LIST)
    menu.action(SCRIPT_META_LIST, "Update Translation File", {}, "This will download the latest translation file for your currently selected language", function()
        show_busyspinner("Fetching translation file...")
        _lang.update_translation_file(SCRIPT)
        HUD.BUSYSPINNER_OFF()
    end)
end
menu.action(SCRIPT_META_LIST, "Upload Logs", {}, "Uploads the last ~20 lines of your stand log (%appdata%\\Stand\\Log.txt) to paste.jackz.me.\nLog uploads are unlisted and will expire 7 days after uploaded.\n\nUploaded log can be accessed from \"Open Uploaded Log\" button below once pressed", function()
    local logs = io.open(filesystem.stand_dir() .. "Log.txt", "r")
    if logs then
        show_busyspinner("Uploading logs....")
        async_http.init("paste.jackz.me", "/paste?textOnly=1&expires=604800", function(body)
            HUD.BUSYSPINNER_OFF()
            local lines = {}
            for s in body:gmatch("[^\r\n]+") do
                table.insert(lines, s)
            end
            local url = lines[3] or ("https://paste.jackz.me/" .. lines[1])
            util.copy_to_clipboard(url, true)
            util.toast("Uploaded: " .. url .. "\nCopied to clipboard", 2)
            menu.hyperlink(SCRIPT_META_LIST, "Open Uploaded Log", url)
                :setTemporary()
        end, function()
            util.toast("Failed to submit logs, network error")
            HUD.BUSYSPINNER_OFF()
        end)
        logs:seek("end", -3072)
        local content = logs:read("*a")
        local standVersion = menu.get_version().full
        async_http.set_post("text/plain",
            string.format("Script: %s\nSource: %s\nBranch: %s\nVersion: %s\nStand Version: %s\nCommit: %s\n\n%s", SCRIPT_NAME, SCRIPT_SOURCE or "UNK", SCRIPT_BRANCH or "UNK", VERSION or "UNK", standVersion, BRANCH_LAST_COMMIT or "DEV BUILD", content)
        )
        async_http.dispatch()
        logs:close()
    else
        util.toast("Could not read your stand log file")
    end
end)

SCRIPT_DEBUG = SCRIPT_SOURCE == nil

function try_require(name, isOptional)
    local status, data = pcall(require, name)
    if status then
        return data
    else
        if data then
            Log.warn(name .. ": " .. data, TOAST_ALL)
        end
        if SCRIPT_SOURCE == "REPO" then
            if isOptional then
                Log.debug("Missing optional dependency: " .. name)
            else
                util.toast("Missing a required depencency (\"" .. name .. "\"). Please install this from the repo > dependencies list")
                Log.severe("Missing required dependency:", name)
            end
        elseif download_lib_update then
            local lockPath = download_lib_update(name, function()
                Log.log("Downloaded ", isOptional and "optional" or "required", "library:", name)
            end)
            while filesystem.exists(lockPath) do
                util.yield(500)
            end
            return require(name)
        end
        return nil
    end
end
-- END TEMPLATE --


util.require_natives(1627063482)

local json = require("json")
local _lang = require("translations")
if _lang.menus == nil or _lang.VERSION == nil or _lang.VERSION ~= LANG_TARGET_VERSION then
  if SCRIPT_SOURCE == "MANUAL" then
    util.toast("Outdated translations library, downloading update...")
    os.remove(filesystem.scripts_dir() .. "/lib/translations.lua")
    package.loaded["translations"] = nil
    _G["translations"] = nil
    download_lib_update("translations.lua")
    _lang = require("translations")
  else
    util.toast("Outdated lib: 'translations'")
  end
end
_lang.set_autodownload_uri("jackz.me", "/stand/git/" .. (SCRIPT_BRANCH or "master")  .. "/resources/Translations/")
_lang.load_translation_file(SCRIPT)

local SETTINGS_PATH = filesystem.store_dir() .. "/jackz_chat.json"

-- begin actual plugin code
local lastTimestamp = os.unixseconds() - 10000 -- Get last 10 seconds
local messages = {}
local user = SOCIALCLUB._SC_GET_NICKNAME() -- don't be annoying.
local waiting = false
local showExampleMessage = false
local sendChannel = "default"
local devToken = nil -- don't waste your time. you're not a dev.
local textColor = { r = 1.0, g = 1.0, b = 1.0, a = 1.0 }
local bgColor = { r = 0.0, g = 0.0, b = 0.0, a = 0.3 }
local chatPos = { x = 0.0, y = 0.4 }
local textOffsetSize = 0.02
local textSize = 0.5
local textTime = 40000 -- 40 seconds
local keyhash = menu.get_activation_key_hash()
local subscribedChannels = { 
  system = true,
  default = true,
  discord = true
}
local sendChatMenu

local SAVE_PATH = filesystem.store_dir() .. "/jackz_chat.json"
local file = io.open(SAVE_PATH, "r")
if file then
  local status, data = pcall(json.decode, file:read("*all"))
  file:close()
  if data then
    if data.subscriptions then
      subscribedChannels = data.subscriptions
    end
  else
    Log.warn("Failed to decode jackz_chat.json: " .. tostring(data))
    Log.toast("Error parsing saved jackz_chat settings, see logs for details")
  end
end

function save_subs()
  local file = io.open(SAVE_PATH, "w")
  file:write(json.encode({ 
    subscriptions = subscribedChannels
  }))
  file:close()
end

--[[
local autoTranslate = {
  incoming_lang = "en",
  outgoing_lang = "en",
  loaded = false,
  active = false
}
local translateMenu
translateMenu = _lang.menus.list(menu.my_root(), "AUTO_TRANSLATE_LIST", {}, function()
  if autoTranslate.loaded then return end
  autoTranslate.loaded = true
  _lang.menus.toggle(menu.my_root(), "AUTO_TRANSLATE_TOGGLE", {"autotranslate"}, function(value)
    autoTranslate.active = value
  end, autoTranslate.active)
  local incoming_langList = menu.list(menu.my_root(), "AUTO_TRANSLATE_INCOMING")
  local outgoing_langList = menu.list(menu.my_root(), "AUTO_TRANSLATE_OUTGOING")
  async_http.init("fuck-python.jackz.me", "/_languages", function(response)
    local json = json.decode(response)
    for _, node in ipairs(json) do
      menu.action(incoming_langList, node.name .. " (" .. node.code .. ")", {"incomingchat" .. node.code}, "Set all incoming chat messages to be translated to this _language", function()
        autoTranslate.incoming_lang = node.code
      end)
      menu.action(outgoing_langList, node.name .. " (" .. node.code .. ")", {"outgoingchat" .. node.code}, "Set all your outgoing messages to be translated to this _language", function()
        autoTranslate.outgoing_lang = node.code
      end)
    end
  end)
end)

chat.on_message(function(senderId, senderName, message, isTeamChat)
  if autoTranslate.active and senderId ~= PLAYER.user() then
    util.toast(translate_text('es', 'en', message))
  end
end)

function translate_text(source_lang, target_lang, text)
  local output
  async_http.init("fuck-python.jackz.me", "/translate?q=" .. text .. "&source=" .. source_lang .. "&target=" .. target_lang, function(body)
    local json = json.decode(body)
    output = json.translatedText
  end)
  while output == nil do
    util.yield()
  end
  return output
end
--]]


local optionsMenu = menu.list(menu.my_root(), _lang.format("DESIGN_NAME"), {}, _lang.format("DESIGN_TEXT"))
menu.divider(menu.my_root(), "")
menu.on_blur(optionsMenu, function(_)
  showExampleMessage = false
end)
local submenus = { optionsMenu }
table.insert(submenus, menu.colour(optionsMenu, _lang.format("DESIGN_CHAT_COLOR_NAME"), {"standchatcolor"}, _lang.format("DESIGN_CHAT_COLOR_DESC"), textColor, false, function(color)
  textColor = color
end))
table.insert(submenus, menu.colour(optionsMenu, _lang.format("DESIGN_BACKGROUND_COLOR_NAME"), {"standchatbgcolor"}, _lang.format("DESIGN_BACKGROUND_COLOR_DESC"), bgColor, true, function(color)
  bgColor = color
end))
table.insert(submenus, menu.slider(optionsMenu, _lang.format("DESIGN_POS_NAME", "X"), {"standx"}, _lang.format("DESIGN_POS_DESC", "X"), -32768, 32767, chatPos.x * 100, 1, function(x)
  chatPos.x = x / 100
end))
table.insert(submenus, menu.slider(optionsMenu, _lang.format("DESIGN_POS_NAME", "Y"), {"standy"}, _lang.format("DESIGN_POS_DESC", "Y"), -32768, 32767, chatPos.y * 100, 1, function(y)
  chatPos.y = y / 100
end))
table.insert(submenus, menu.slider(optionsMenu, _lang.format("DESIGN_TEXT_SIZE_NAME"), {"standchatsize"}, _lang.format("DESIGN_TEXT_SIZE_DESC"), 20, 100, textSize * 100, 1, function(size)
  textSize = size / 100
  local _, height = directx.get_text_size("Example", textSize)
  textOffsetSize = height
end))
table.insert(submenus, menu.slider(optionsMenu, _lang.format("DESIGN_MESSAGE_DURATION_NAME"), {"standchatmsgtime"}, _lang.format("DESIGN_MESSAGE_DURATION_DESC"), 15, 240, textTime / 1000, 1, function(time)
  textTime = time * 1000 -- convert seconds to ms
end))
for _, submenu in ipairs(submenus) do
  menu.on_focus(submenu, function(_)
    showExampleMessage = true
  end)
end
local subscribedChannelsList = _lang.list(menu.my_root(), "SUBSCRIBED_CHANNELS", {})
_lang.divider(subscribedChannelsList, "PUBLIC_CHANNELS")
function add_subscribe_entry(channel, description, defaultOn, isCustom)
  local id = channel:lower()
  if defaultOn then
    subscribedChannels[id] = true
    save_subs()
  end
  local entry
  if isCustom then
    description = description .. "\n\n" .. _lang.format("CHANNEL_SUB_DELETE_HINT")
  end
  entry = menu.toggle(subscribedChannelsList, channel, {"chatsub" .. id}, description, function(on)
    if PAD.IS_CONTROL_PRESSED(2, 209) then
      subscribedChannels[id] = nil
      _lang.toast("CHANNEL_SUB_DELETED", channel)
      menu.delete(entry)
    else
      subscribedChannels[id] = on
      if on then
        _lang.toast("CHANNEL_SUB_ENABLE", channel)
      else
        _lang.toast("CHANNEL_SUB_DISABLE", channel)
      end
    end
    save_subs()
  end, subscribedChannels[id])
end
add_subscribe_entry("System", _lang.format("CHANNEL_SUB_SYSTEM"))


local channelList = menu.list(menu.my_root(), _lang.format("CHANNELS_NAME"), {}, _lang.format("CHANNELS_DESC") .. "\n\n" .. _lang.format("CHANNELS_ACTIVE", "default"))
function switchChannel(channel)
  sendChannel = channel
  menu.set_help_text(channelList, _lang.format("CHANNELS_DESC") .. "\n\n" .. _lang.format("CHANNELS_ACTIVE", channel))
  menu.set_menu_name(sendChatMenu, _lang.format("SEND_MSG_NAME", sendChannel))
  menu.set_help_text(sendChatMenu, _lang.format("SEND_MSG_DESC") .. "\n\n" .. _lang.format("SEND_CHAT_AS", user, sendChannel))
  _lang.toast("CHANNELS_SWITCHED", channel)
end

async_http.init("jackz.me", "/stand/chat/info", function(body)
  if body:sub(1, 1) == "{" then
    local data = json.decode(body)

    for _, channel in ipairs(data.publicChannels) do
      menu.action(channelList, channel, {"chat_lang" .. channel}, _lang.format("CHANNELS_SWITCH_TO", channel), function(_)
        switchChannel(channel)
      end)
      local desc = _lang.get_raw_string("CHANNEL_SUB_" .. channel) or _lang.format("CHANNEL_SUB_PUBLIC")
      add_subscribe_entry(channel, desc, subscribedChannels[channel] or false)
    end

    -- Add custom subscription input
    _lang.divider(subscribedChannelsList, "CUSTOM_CHANNELS")
    _lang.text_input(subscribedChannelsList, "CHANNEL_SUB_ADDCUSTOM", {"chatsubaddcustom"}, function(value)
      if value == "" then end
      add_subscribe_entry(value, _lang.format("CHANNEL_SUB_CUSTOM"), true)
    end, "")

    -- Load custom subscription inputs
    for channel, value in pairs(subscribedChannels) do
      -- Don't show system (not listed as public channel), default to false unless system
      local isPublicChannel = channel == "system"
      if not isPublicChannel then
        -- Check if channel is also public channel, thus public, not custom
        for _, publicChannel in ipairs(data.publicChannels) do
          if channel == publicChannel then
            isPublicChannel = true
            break
          end
        end
      end
      -- If custom
      if not isPublicChannel then
        add_subscribe_entry(channel, _lang.format("CHANNEL_SUB_CUSTOM"), value, true)
      end
    end
  else
    util.toast("Jackz Chat server returned an error, see logs")
    Log.warn(body)
  end
end, function() util.toast("Could not fetch public channels") end)
async_http.dispatch()



menu.text_input(channelList, _lang.format("CHANNELS_SPECIFIC_NAME"), { "chatchannel" } , _lang.format("CHANNELS_SPECIFIC_DESC"), function(args)
  if args == "" then return end
  args = args:gsub('%W','')
  if string.len(args) == 0 or args == "_all" or args == "system" then
    -- Before you try to bypass this, it's handled on the server side.
    _lang.toast("CHANNELS_SPECIFIC_INVALID")
  else
    switchChannel(string.lower(args))
  end
end)

sendChatMenu = menu.text_input(menu.my_root(), _lang.format("SEND_MSG_NAME", sendChannel), { "chat", "c" }, _lang.format("SEND_MSG_DESC") .. "\n\n" .. _lang.format("SEND_CHAT_AS", user, sendChannel), function(args, clickType)
  if args == "" then return end
  show_busyspinner("Sending messsage")
  async_http.init("jackz.me", "/stand/chat/channels/" .. sendChannel .. "?v=" .. VERSION, function(result, headers, status_code)
    if status_code == 204 or result == "OK" or result == "Bad Request" then
      table.insert(messages, {
        u = user,
        c = args:sub(1,100),
        t = os.unixseconds() * 1000,
        l = sendChannel
      })
    elseif result == "MAINTENANCE" then
      _lang.toast("SEND_MAINTENANCE")
    elseif result == "RATELIMITED" then
      _lang.toast("SEND_RATELIMITED")
    else
      _lang.toast("SEND_ERR" .. result)
    end
    HUD.BUSYSPINNER_OFF()
  end, function() HUD.BUSYSPINNER_OFF() end)
  async_http.set_post("application/json", json.encode({
    user = user,
    content = args,
    hash = keyhash,
    rid = players.get_rockstar_id(players.user())
  }))
  async_http.dispatch()
  sendChatMenu:applyDefaultState()
end)


util.create_tick_handler(function(_)
  waiting = true
  local subList = {}
  for k, v in subscribedChannels do
    if v then
      table.insert(subList, k)
    end
  end
  async_http.init("jackz.me", 
    "/stand/chat/channels/" .. sendChannel .. "/" .. lastTimestamp .. "?channels=" .. table.concat(subList, ","), 
    function(body, res_headers, status_code)
    -- check if response is validish json (incase ratelimitted)
    -- Also ignore all errors, and 204 no content
    if status_code == 200 and body:sub(1, 1) == "{" then
      local data = json.decode(body)
      for _, message in ipairs(data.m) do
        if message.u ~= user then
          table.insert(messages, message)
        end
        -- max 20 messages
        if #messages > 20 then
          table.remove(messages, 1)
        end
      end
      lastTimestamp = data.t
    end
    waiting = false
  end)
  if devToken then -- don't even try, you arent finding the token
    async_http.add_header("x-dev-token", devToken)
  end
  async_http.dispatch()
  while waiting do --wait until last fetch finishes
    util.yield()
  end
  util.yield(7000)
  return true
end)

while true do
  local i = 0
  local now = os.unixseconds() * 1000
  local width = 0.0
  for a, msg in ipairs(messages) do
    if now - msg.t > textTime then
      table.remove(messages, a)
    else
      local content
      if msg.ip then -- Only for jackz :)
        content = msg.l and string.format("[%s] [%s] %s: %s", msg.ip, msg.l, msg.u, msg.c) or string.format("[%s] %s: %s", msg.ip, msg.u, msg.c)
      else
        content = msg.l and string.format("[%s] %s: %s", msg.l, msg.u, msg.c) or (msg.u .. ": " .. msg.c)
      end
      -- compute largest width of text, to set chatbot width
      local w = directx.get_text_size(content, textSize)
      if w > width then
        width = w
      end
      directx.draw_text(chatPos.x, chatPos.y + (textOffsetSize * i), content, ALIGN_CENTRE_LEFT, textSize, textColor, true)
      i = i + 1
    end
  end
  directx.draw_rect(chatPos.x, chatPos.y - (textOffsetSize / 2), width + 0.005, textOffsetSize * i, bgColor)
  if showExampleMessage then
    directx.draw_text(chatPos.x, chatPos.y - textOffsetSize, _lang.format("EXAMPLE_1", VERSION), ALIGN_CENTRE_LEFT, textSize, textColor, true)
    directx.draw_text(chatPos.x, chatPos.y - (textOffsetSize * 2), _lang.format("EXAMPLE_2"), ALIGN_CENTRE_LEFT, textSize, textColor, true)
    directx.draw_text(chatPos.x, chatPos.y - (textOffsetSize * 3), _lang.format("EXAMPLE_3"), ALIGN_CENTRE_LEFT, textSize, textColor, true)
    directx.draw_rect(chatPos.x, chatPos.y - (textOffsetSize * 3) - (textOffsetSize / 2), 0.3 + 0.2 * textSize, textOffsetSize * 3, bgColor)
  end
	util.yield()
end